# 코딩테스트 문제 풀이 기록

## 1. 문제 유형
<!-- 예: DP, BFS/DFS, 그리디, 정렬 등 -->
- 문자열 파싱, 단순 구현

## 2. 배운 점
<!-- 문제를 풀면서 새롭게 알게 된 내용, 활용한 알고리즘/자료구조 -->
- 정규식을 활용하면 숫자와 문자 손쉽게 분리 가능 (split("\\D+")로 숫자만 추출, replaceAll("[0-9]", "")로 문자만 추출)
- S, D, T 보너스를 제곱 연산으로 처리하는 방식이 규칙과 잘 맞음
- 옵션(*, #)은 현재 점수와 이전 점수에 조건부로 적용되므로 배열로 점수를 관리하는 것이 적합함

## 3. 개선할 점
<!-- 문제를 풀면서 아쉬웠던 점, 다음에 더 잘할 수 있는 부분 -->
- 옵션 처리 시 인덱스(count) 증가 타이밍이 섬세해야 하는데, 현재 방식은 보너스/옵션 구분이 명확하지 않아 구조적으로 취약한 부분이 있음
- 숫자/문자 분리를 두 단계(split + replace)로 했지만, 정규식 한 번으로 토큰을 순서대로 파싱하는 방식이 더 안정적일 수 있음
- 보너스(S, D, T) 뒤에 옵션이 올지 말지를 조건문으로 판별하는 로직이 복잡해졌기 때문에, 한 턴을 '완성되었는지' 판단하는 명확한 플로우가 필요함

## 4. 추가 연습이 필요한 부분
<!-- 유사 문제나 더 연습이 필요한 알고리즘/자료구조 또는 부족한 부분 -->
- 문자열을 앞에서부터 순서대로 "토큰 단위"로 파싱하는 구현 방식
- 보너스와 옵션이 연속적으로 등장하는 패턴에 대한 처리
- 10처럼 두 자리 숫자가 포함될 때 안정적으로 처리하는 로직

## 5. 문제에서 가장 어려웠던 점
<!-- 설계, 구현, 디버깅 등 어려웠던 부분 상세히 기록 -->
- 보너스(S, D, T) 뒤에 옵션(*,#)이 붙을 수도 있고 안 붙을 수도 있어, 턴 종료 시점을 정확히 잡는 부분이 까다로웠음
- 옵션(*)은 현재 점수와 이전 점수에 동시에 영향을 주기 때문에 배열 인덱스를 잘못 올리면 전체 결과가 틀어지는 문제가 있었음
- splitChar 기준으로만 턴 종료를 판별하면 예외 케이스가 발생하여 카운팅 흐름이 종종 꼬일 수 있었음

## 6. 다른 접근 방식
<!-- 다른 풀이 방법이 있었다면 기록 -->
- 반정규식을 사용하여 "점수 + 보너스 + 옵션?"을 한 번에 매칭하는 방식
	- 예: (\d+)([SDT])([*#]?)
		- 이렇게 하면 각 턴을 명확한 묶음 처리로 처리 가능
- 스택 기반으로 점수를 쌓고 S/D/T 처리 후 옵션을 반영하는 방식
	- 옵션 처리 시 직전 값도 쉽게 접근할 수 있어 로직 단순화 가
