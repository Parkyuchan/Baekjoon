# 코딩테스트 문제 풀이 기록

## 1. 문제 유형
<!-- 예: DP, BFS/DFS, 그리디, 정렬 등 -->
- 완전 탐색, 구현

## 2. 배운 점
<!-- 문제를 풀면서 새롭게 알게 된 내용, 활용한 알고리즘/자료구조 -->
- 명령마다 범위 검증과 장애물 검증을 모두 해야하며, 검증 실패 시 전체 명령을 무시하는 흐름을 설계하는 방식이 익숙해졌다.
- 2차원 문자열 배열을 숫자 매트릭스로 변환하여 이동 가능 여부를 관리하는 방식의 장단점을 체감했다.

## 3. 개선할 점
<!-- 문제를 풀면서 아쉬웠던 점, 다음에 더 잘할 수 있는 부분 -->
- 방향별 코드가 거의 동일한 구조임에도 중복되어 있어, 하나의 공통 메서드로 추출하면 가독성이 개선될 수 있음
- 경계 체크에서 answer[1] + Integer.parseInt(infor[1]) >= ... 형태로 "전체 이동값을 한 번에 검사"하는 방식은 겉으로는 맞지만, 사실상 루프 내부의 j 검사만으로 충분하며 중복 검사 요소가 있음

## 4. 추가 연습이 필요한 부분
<!-- 유사 문제나 더 연습이 필요한 알고리즘/자료구조 또는 부족한 부분 -->
- grid 기반 시뮬레이션 구현에서 "중복되는 이동 로직을 추상화"하는 구조화 연습
- 방향을 hash map이나 dx/dy 배열로 통일해 처리하는 방식
- 경계 조건과 장애물 검증 같은 구현 문제에서 반복되는 실수를 줄이는 패턴 익히기

## 5. 문제에서 가장 어려웠던 점
<!-- 설계, 구현, 디버깅 등 어려웠던 부분 상세히 기록 -->
- 한 번의 이동 명령이 여러 칸 이동을 포함할 때 "중간 칸 중 하나라도 막히면 전체 이동 무효" 조건을 바로 파악하지 못했음
- 모든 방향에 대해 동일한 검증 구조를 유지하면서 오류 없이 구현하는 과정이 다소 복잡함

## 6. 다른 접근 방식
<!-- 다른 풀이 방법이 있었다면 기록 -->
- 방향을 Map<String, int[]> 형태로 관리하여 dx/dy 기반으로 한 루프로 모든 방향을 처리하는 방식
- map 배열을 굳이 숫자가 아닌 boolean 배열로 구성하면 더 직관적
